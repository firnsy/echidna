#!/usr/bin/perl
#
# This file is part of the NSM framework
#
# Copyright (C) 2010-2011, Edward Fjellsk√•l <edwardfjellskaal@gmail.com>
#                          Eduardo Urias    <windkaiser@gmail.com>
#                          Ian Firns        <firnsy@securixlive.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License Version 2 as
# published by the Free Software Foundation.  You may not use, modify or
# distribute this program under any other version of the GNU General
# Public License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
use File::Spec;
use FindBin qw($Bin);
use lib File::Spec->catdir($Bin, '..', 'lib');

use warnings;
use strict;
use v5.10;

#
# PERL INCLUDES
#
use Carp;
use Data::Dumper;
use Digest::SHA qw(sha256_hex);
use POE;
use POE::Component::Client::TCP;
use POE::Wheel::ReadLine;
use POSIX;
use Term::ReadKey;

#
# NSMF INCLUDES
#
use NSMF::Client;
use NSMF::Client::ConfigMngr;

use NSMF::Common::JSON;
use NSMF::Common::Logger;
use NSMF::Common::Registry;
use NSMF::Common::Util;

#
# GLOBALS
#
our $VERSION = '0.1';
my $prompt = 'echidna';

#
# CONSTANTS
#
my $commands_all = [
    {
        command => "exit",
        help => "Exit the Echidna client.\n\n" .
                "Usage: exit | x | quit | q",
        function => "client_exit",
    },
    {
        command => "connect",
        help => "Connect to the specified Echidna server.\n\n" .
                "Usage: connect [options] --host=ip --user=name\n\n" .
                "Options:\n" .
                "  --host=ip    IP address of the Echidna server to connect to.\n" .
                "  --user=name  Client name to connect with.",
        function => "server_connect",
    },
    {
        command => "disconnect",
        help => "Disconnect from the Echidna server.\n\n" .
                "Usage: disconnect",
        function => "server_disconnect",
    },
    {
        command => "register client",
        help => "Register a client to the Echidna framework.\n\n" .
                "Usage: register client [options] --name=name --password=password --acl=level\n\n" .
                "Options:\n" .
                "  --name=name          Unique name.\n" .
                "  --password=password  Defines the password for the new client.\n" .
                "  --acl=level          Level of access applied to the new client. [0-255] \n" .
                "  --description=blah   A description of the new client.",
        function => "register_client",
        api => { core => [ "register_client" ] }
    },
    {
        command => "unregister client",
        help => "Unregister a client from the Echidna frameworkn\n\n" .
                "Usage: unregister client --id=client\n\n" .
                "Options:\n" .
                "  --id=client  Unique client id.",
        function => "unregister_client",
        api => { core => [ "unregister_client" ] }
    },
    {
        command => "update client",
        help => "Update a registered client's details on the Echidna framework.\n\n" .
                "Usage: update client [options] --id=client --password=password --acl=level\n\n" .
                "Options:\n" .
                "  --id=client          Registered id for client.\n" .
                "  --name=name          Unique name.\n" .
                "  --password=password  Defines the password for the new client.\n" .
                "  --acl=level          Level of access applied to the new client. [0-255] \n" .
                "  --description=blah   A description of the new client.",
        function => "update_client",
        api => { core => [ "update_client" ] }
    },
    {
        command => "register node",
        help => "Register a node to the Echidna framework.\n\n" .
                "Usage: register node [options] --name=name --agent=agent --password=password\n\n" .
                "Options:\n" .
                "  --name=name          Unique name.\n" .
                "  --agent=agent        Regsitered id of the parent agent.\n" .
                "  --password=password  Defines the password for the new node.\n" .
                "  --description=blah   A description of the new node.",
        function => "register_node",
        api => { core => [ "register_node" ] }
    },
    {
        command => "unregister node",
        help => "Unregister a node from the Echidna frameworkn\n\n" .
                "Usage: unregister node --id=agent\n\n" .
                "Options:\n" .
                "  --id=agent  Unique agent id.",
        function => "unregister_node",
        api => { core => [ "unregister_node" ] }
    },
    {
        command => "update node",
        help => "--id",
        function => "update_node",
        api => { core => [ "update_client" ] }
    },
    {
        command => "register agent",
        help => "Register an agent to the Echidna framework.\n\n" .
                "Usage: register node [options] --name=name --password=password\n\n" .
                "Options:\n" .
                "  --name=name          Unique name.\n" .
                "  --password=password  Defines the password for the new agent.\n" .
                "  --description=blah   A description of the new agent.",
        function => "register_agent",
        api => { core => [ "register_agent" ] }
    },
    {
        command => "unregister agent",
        help => "Unregister an agent from the Echidna frameworkn\n\n" .
                "Usage: unregister agent --id=agent\n\n" .
                "Options:\n" .
                "  --id=agent  Unique agent id.",
        function => "unregister_agent",
        api => { core => [ "unregister_agent" ] }
    },
    {
        command => "update agent",
        help => "--id",
        function => "update_agent",
        api => { core => [ "update_agent" ] }
    },
    {
        command => "search event",
        help => "Search through the all captured events.\n\n" .
                "Usage: search event [options]\n\n" .
                "Options:\n" .
                "  --timestamp=timestamp    Filter on timestamp recorded.\n\n" .
#               "  --agent-id=id            Filter on events specific to the agent's id\n" .
                "  --node-id=id             Filter on events specific to the node's id\n\n" .
                "  --src-ip=ip              Filter on source ip.\n" .
                "  --src-port=port          Filter on source port.\n\n" .
                "  --dst-ip=ip              Filter on destination ip.\n" .
                "  --dst-port=port          Filter on destination port.\n" .
                "  --ip=ip                  Filter on either source or destination ip.\n" .
                "  --port=port              Filter on either source or destination port.\n\n" .
                "  --protocol=protocol      Filter on TCP/IP protocol.\n" .
                "  --version=version        Filter on IP version. (eg. 4 or 6).\n\n" .
                "  --sig-id=id              Filter on signature id).\n" .
                "  --sig-revision=revision  Filter on signature revision.\n" .
                "  --sig-priority=priority  Filter on signature priority.\n" .
                "  --sig-message=message    Filter on signature message.\n" .
                "  --sig-category=category  Filter on signature category.\n" ,
        function => "search_event",
        api => { core => [ "search_event" ] }
    },
    {
        command => "search session",
        help => "Usage: search session [options]\n\n" .
                "Options:\n" .
                "  --time-start=timestamp  Filter on timestamp of first packet.\n" .
                "  --time-end=timestamp    Filter on timestamp of last packet.\n" .
                "  --time-duration=n       Filter on n seconds of duration.\n\n" .
#               "  --agent-id=id           Filter on sessions specific to the agent's id\n" .
                "  --node-id=id            Filter on sessions specific to the node's id\n\n" .
                "  --src-ip=ip             Filter on source ip.\n" .
                "  --src-port=port         Filter on source port.\n" .
                "  --src-total-bytes=n     Filter on total n bytes sent from source.\n" .
                "  --src-total-packets=n   Filter on total n packets sent from source.\n" .
                "  --src-flags             Filter on total flags (bitwise-or'd) of packets sent from source.\n\n" .

                "  --dst-ip=ip             Filter on destination ip.\n" .
                "  --dst-port=port         Filter on destination port.\n" .
                "  --dst-total-bytes=n     Filter on total n bytes sent from destination.\n" .
                "  --dst-total-packets=n   Filter on total n packets sent from destination.\n" .
                "  --dst-flags             Filter on total flags (bitwise-or'd) of packets sent from destination.\n\n" .
                "  --ip=ip                 Filter on either source or destination ip.\n" .
                "  --port=port             Filter on either source or destination port.\n\n" .
                "  --protocol=protocol     Filter on TCP/IP protocol.\n" .
                "  --version=version       Filter on IP version. (eg. 4 or 6).\n",
        function => "search_session",
        api => { core => [ "search_session" ] }
    },
    {
        command => "show clients",
        help => "Show all clients currently connected to Echidna.\n",
        function => "show_clients",
        api => { core => [ "clients_connected" ] }
    },
    {
        command => "show nodes",
        help => "Show all nodes currently connected to Echidna.\n",
        function => "show_nodes",
        api => { core => [ "nodes_connected" ] }
    },
    {
        command => "node uptime",
        help => "Show how long the specified Echidna node has been up.\n",
        function => "show_node_uptime",
        api => { core => [ "node_uptime" ] }
    },
    {
        command => "node version",
        help => "Show the version and build information for the specified Echidna node.\n",
        function => "show_node_version",
        api => { core => [ "node_version" ] }
    },
    {
        command => "server uptime",
        help => "Show how long the Echidna server has been up.\n",
        function => "show_server_uptime",
        api => { core => [ "server_uptime" ] }
    },
    {
        command => "server version",
        help => "Show the version and build information for the Echidna server.\n",
        function => "show_server_version",
        api => { core => [ "server_version" ] }
    },
    {
        command => "node subscribe",
        help => "Subscribe to the specified nodes events.\n",
        function => "subscribe_node",
        api => { core => [ "subscribe_node" ] }
    }
];


# set base path on server singleton
$NSMF::Client::BASE_PATH = File::Spec->catdir($Bin, '../');

my $config_path = File::Spec->catfile($NSMF::Client::BASE_PATH, 'etc', 'client.yaml');

croak 'Server Configuration File Not Found'
    unless -f -r $config_path;

my $config = NSMF::Client::ConfigMngr->load($config_path);
$NSMF::Common::Logger::LOG_DIR = $NSMF::Client::BASE_PATH . '/logs';

my $logger = NSMF::Common::Logger->load($config->{config}{log});
my $reg    = NSMF::Common::Registry->new;
$reg->set( 'log'    => $logger );
$reg->set( 'config' => $config );

my $echidna = NSMF::Client->new();
my $proto   = $echidna->proto();

my ($self) = @_;

my $host = undef;
my $port = undef;
my $user = undef;
my $pass = undef;

my $module_active = 'core';
my $modules = [];
my $api_commands = {};
my $commands_available = [];

# session flags
my $exiting = 0;     # is the client exiting
my $connected = 0;   # is the client connected to a server
my $connecting = 0;  # is the client connected to a server


# perform a check now to validate our command list

POE::Session->create(
    inline_states => {
        _start => sub {
            my ($kernel, $heap) = @_[KERNEL, HEAP];

            $kernel->alias_set('console');

            # build up
            $heap->{console} = POE::Wheel::ReadLine->new(
                InputEvent => "got_input",
                PutMode => "immediate",
            );

            $kernel->call("console", "check_available_commands");

            # show we are ready to recieve user prompt
            $heap->{console}->get( get_prompt() );
        },
        _stop => sub {
            my ($kernel, $heap) = @_[KERNEL, HEAP];

            $kernel->alias_remove('console');

            delete $heap->{console};

            if ( $connected ) {
                $kernel->post("client", "shutdown");
            }
        },

        load_session => \&load_session,
        check_available_commands => \&check_available_commands,

        #
        # CLIENT INTERNAL FUNCTIONS
        #
        got_input => \&got_input,
        put_output => \&put_output,

        #
        # CLIENT CLI COMMAND FUNCTIONS
        #

        client_exit => \&client_exit,

        register_client => \&register_client,
        unregister_client => \&unregister_client,
        update_client => \&update_client,

        register_node => \&register_node,
        unregister_node => \&unregister_node,
        update_node => \&update_node,

        subscribe_node => \&subscribe_node,

        register_agent => \&register_agent,
        unregister_agent => \&unregister_agent,
        update_agent => \&update_agent,

        search_event => \&search_event,
        search_session => \&search_session,

        show_clients => \&show_clients,
        show_nodes => \&show_nodes,

        show_server_uptime => \&show_server_uptime,
        show_server_version => \&show_server_version,

        show_node_uptime => \&show_node_uptime,
        show_node_version => \&show_node_version,

        server_connect => \&server_connect,
        server_disconnect => \&server_disconnect,
    }
);

POE::Kernel->run();

exit(0);


#
# FUNCTIONS
#

sub load_session
{
    my ($kernel, $heap) = @_[KERNEL, HEAP];

    # clear existing known commands
    $commands_available = [];

    $kernel->call("console", "check_available_commands");

    # start the query process
    $kernel->post('client', 'get', {
        type => 'core',
        data => 'modules_available'
    }, sub {
        my ($s, $k, $h, $json) = @_;

        my $modules = $json->{result} // [];

        foreach my $m ( @{ $modules } ) {
            $api_commands->{$m} = undef;

            $k->post('client', 'get', {
                type => $m,
                data => 'commands_available'
            }, sub {
                my ($s, $k, $h, $json) = @_;

                my $commands = $json->{result} // [];

                $api_commands->{$m} = $commands;
                $k->post("console", "check_available_commands");
            });
        }
    });
}

sub check_available_commands {
    my ($kernel, $heap) = @_[KERNEL, HEAP];

    # loop through each command possible
    foreach my $c ( @{ $commands_all } ) {

        # determine if the "api" requirements are met
        my $api = $c->{api} // {};

        # we should have a HASH reference with keys defining the api modules required
        if( ref($api) ne 'HASH' ) {
            say("ERROR: Command list is tainted.");
            exit 1;
        }

        # assume supported unless proven otherwise
        my $supported = 1;

        # loop through each api module required
        foreach my $m ( keys( %{ $api } ) ) {

            # we should have the values as ARRAY reference describing all required
            # api module commands required
            if( ref($api->{$m}) ne 'ARRAY' ) {
                say("ERROR: Command list is tainted.");
                exit 1;
            }

            # check the api module exists first
            if( defined($api_commands->{$m}) &&
                ref($api_commands->{$m}) eq 'ARRAY' ) {

                # loop through all require api module commands
                foreach my $mc ( @{ $api->{$m} } ) {

                    # check if the api module command is available
                    if ( ! grep { $_ eq $mc } @{ $api_commands->{$m} } ) {
                        $supported = 0;
                        last;
                    }
                }
            }
            else {
                $supported = 0;
                last;
            }
        }

        if ( $supported &&
             ! grep { $_->{command} eq $c->{command} } @{ $commands_available } ) {
            push( @{ $commands_available }, $c );
        }
    }
}

sub put_output {
    my ($heap, $data) = @_[HEAP, ARG0];

    $heap->{console}->put($data);
}


sub got_input
{
    my ($kernel, $heap, $data, $exception) = @_[KERNEL, HEAP, ARG0, ARG1];

    # ignore all input if we are exiting
    return if ( $exiting );

    if ( defined($data) ) {
        my $processed = 0;

        if ( length($data) ) {

            # loop through all available commands
            foreach my $c ( @{ $commands_available } ) {
                $processed |= $kernel->call('console', $c->{function}, $data);
                last if ( $processed );
            }

            if( ! $processed ) {
                # no commands seen
                if( $data =~ /^(help|h|\?)\s?(.*)$/ ) {
                    my $extra = $2;

                    if( length($extra) ) {
                        for my $c (@{ $commands_available }) {
                            if ( $c->{command} eq $extra ) {
                                $kernel->call('console', 'put_output', "\n" . $c->{help} . "\n");
                                last;
                            }
                        }
                    }
                    else {
                        my $help = "\nAvailable commands:\n";

                        for my $c (@{ $commands_available }) {
                            $help .= '  ' . $c->{command} . "\n";
                        }

                        $kernel->call('console', 'put_output', $help);
                    }

                    # we've displayed some form of help
                    $processed = 1;
                }
            }

            if ( ! $processed ) {
                $kernel->call('console', 'put_output', "\n" . 'Command not supported: ' . $data . "\n");
            }
            else {
                $heap->{console}->add_history($data);
            }
        }
    }
    elsif( $exception eq 'interrupt' ) {

    }

    # show we are ready to receive input if we're not exiting
    if ( ! $exiting ) {
        $heap->{console}->get( get_prompt() );
    }
}


sub get_prompt {
    return $prompt . '> ';
}


#
# COMMAND TESTING AND PROCESSING
#

sub client_exit {
    my ( $kernel, $heap, $data) = @_[KERNEL, HEAP, ARG0];

    if( $data =~ /^(quit|exit|q|x)$/ ) {
        $exiting = 1;

        $kernel->yield("_stop");

        return 1;
    }

    return 0;
}

sub server_connect {
    my ( $kernel, $heap, $data) = @_[KERNEL, HEAP, ARG0];

    if( $data =~ /^connect\s?(.*)/) {

        $host = $config->host() // 'localhost';
        $port = $config->port() // 10101;
        $user = undef;
        $pass = undef;

        my @search_args = split(/[ ]/, $1);

        foreach my $k ( @search_args ) {
            given( $k ) {
                when(/^--user=([^ ]*)/) {
                    $user = $1;
                }
                when(/^--password=([^ ]*)/) {
                    $pass = sha256_hex($1);
                }
                when(/^--host=([^ ]*)/) {
                    $host = $1;
                }
                when(/^--port=([^ ]*)/) {
                    $port = $1;
                }
                default {
                    $kernel->call('console', 'put_output', 'Unsupported parameter: ' . $k);
                    return 1;
                }
            }
        }

        if ( ! defined($user) ) {
            $kernel->call('console', 'put_output', 'No user specified');
            return 1;
        }

        $connecting = 1;

        $kernel->call('console', 'put_output', 'Connecting to ' . $user . '@' . $host . ':' . $port . '...');
        print('Password: ');
        ReadMode "noecho";
        $pass = <STDIN>;
        chomp($pass);
        $pass = sha256_hex($pass);
        ReadMode "restore";
        $kernel->call('console', 'put_output', '');

        delete $heap->{client} if ( defined($heap->{client}) );

        $heap->{client} = POE::Component::Client::TCP->new(
            Alias         => 'client',
            RemoteAddress => $host,
            RemotePort    => $port,
            Filter        => "POE::Filter::Line",
            Connected => sub {
                my ($kernel, $heap) = @_[KERNEL, HEAP];
                $kernel->call("console", "put_output", "\nConnected.\n");

                $heap->{stage}  = '';
                $heap->{name}   = $user;
                $heap->{secret} = $pass;

                $kernel->post('console', 'init');
                $kernel->yield('authenticate');

                $connecting = 0;
                $connected = 1;
            },
            ConnectError => sub {
                my ($kernel, $heap, $error_string) = @_[KERNEL, HEAP, ARG2];
                $kernel->call("console", "put_output", "\nUnable to connect: " . $error_string . "\n");
            },
            ServerInput => sub {
                my ($kernel, $response) = @_[KERNEL, ARG0];

                $kernel->yield(dispatcher => $response);
            },
            ServerError => sub {
                my ($kernel, $heap) = @_[KERNEL, HEAP];
                $kernel->call("console", "put_output", "\nLost connection to server...\n");
            },
            Disconnected => sub {
                $kernel->call("console", "put_output", "\nDisconnected\n");
            },
            ObjectStates => [
                $proto => $proto->states(),
            ],
        );

        return 1;
    }

    return 0;
}

sub server_disconnect {
    my ( $kernel, $heap, $data) = @_[KERNEL, HEAP, ARG0];

    if( $data =~ /^disconnect(.*)/) {

        $kernel->post("client", "shutdown");

        return 1;
    }

    return 0;
}


sub register_agent {
    my ($kernel, $heap, $data) = @_[KERNEL, HEAP, ARG0];

    if( $data =~ /^register\sagent\s?(.*)/) {
        my $sql = {};

        my @search_args = split(/[ ]/, $1);

        foreach my $k ( @search_args ) {
            given( $k ) {
                when(/^--name=([^ ]*)/) {
                    $sql->{name} = $1;
                }
                when(/^--password=([^ ]*)/) {
                    $sql->{password} = sha256_hex($1);
                }
                when(/^--description=([^ ]*)/) {
                    $sql->{description} = $1;
                }
                default {
                    $kernel->call('console', 'put_output', 'Unsupported parameter: ' . $k);
                    return 1;
                }
            }
        }

        if( ! defined_args( $sql->{name},
                            $sql->{password} ) ) {
            $kernel->call('console', 'put_output', "Mandatory arguments are missing.");
            return 1;
        }

        $kernel->post('client', 'get', {
            type => "core",
            data => {
              "register_agent" => $sql
            },
        }, sub {
            my ($s, $k, $h, $json) = @_;

            my $result = $json->{result} // [];

            # TODO post process result with client aware components

            $kernel->call('console', 'put_output', Dumper($result));
        });

        return 1;
    }

    return 0;
}

sub update_agent {
    my ($kernel, $heap, $data) = @_[KERNEL, HEAP, ARG0];

    if( $data =~ /^update\sagent\s?(.*)/) {
        my $sql = {};

        my @search_args = split(/[ ]/, $1);

        foreach my $k ( @search_args ) {
            given( $k ) {
                when(/^--id=([^ ]*)/) {
                    $sql->{id} = $1;
                }
                when(/^--name=([^ ]*)/) {
                    $sql->{name} = $1;
                }
                when(/^--password=([^ ]*)/) {
                    $sql->{password} = sha256_hex($1);
                }
                when(/^--description=([^ ]*)/) {
                    $sql->{description} = $1;
                }
                default {
                    $kernel->call('console', 'put_output', 'Unsupported parameter: ' . $k);
                    return 1;
                }
            }
        }

        if( ! defined_args( $sql->{id} )  ){
            $kernel->call('console', 'put_output', "Mandatory arguments are missing.");
            return 1;
        }

        $kernel->post('client', 'get', {
            type => "core",
            data => {
              "update_agent" => $sql
            },
        }, sub {
            my ($s, $k, $h, $json) = @_;

            my $result = $json->{result} // [];

            # TODO post process result with client aware components

            $kernel->call('console', 'put_output', Dumper($result));
        });

        return 1;
    }

    return 0;
}

sub unregister_agent {
    my ($kernel, $heap, $data) = @_[KERNEL, HEAP, ARG0];

    if( $data =~ /^unregister\sagent\s?(.*)/) {
        my $sql = {};

        my @search_args = split(/[ ]/, $1);

        foreach my $k ( @search_args ) {
            given( $k ) {
                when(/^--id=([^ ]*)/) {
                    $sql->{id} = $1;
                }
                default {
                    $kernel->call('console', 'put_output', 'Unsupported parameter: ' . $k);
                    return 1;
                }
            }
        }

        $kernel->post('client', 'get', {
            type => "core",
            data => {
              "unregister_agent" => $sql
            },
        }, sub {
            my ($s, $k, $h, $json) = @_;

            my $result = $json->{result} // [];

            # TODO post process result with client aware components

            $kernel->call('console', 'put_output', Dumper($result));
        });

        return 1;
    }

    return 0;
}

sub register_client {
    my ($kernel, $heap, $data) = @_[KERNEL, HEAP, ARG0];

    if( $data =~ /^register\sclient?(.*)/) {
        my $sql = {};

        my @search_args = split(/[ ]/, $1);

        if( @search_args == 0 ) {
            $kernel->call('console', 'put_output', "I need arguments.");
            return 0;
        }

        foreach my $k ( @search_args ) {
            given( $k ) {
                when(/^--name=([^ ]*)/) {
                    $sql->{name} = $1;
                }
                when(/^--acl=([^ ]*)/) {
                    $sql->{level} = $1;
                }
                when(/^--password=([^ ]*)/) {
                    $sql->{password} = sha256_hex($1);
                }
                when(/^--description=([^ ]*)/) {
                    $sql->{description} = $1;
                }
                default {
                    $kernel->call('console', 'put_output', 'Unsupported parameter: ' . $k);
                    return 1;
                }
            }
        }

        if( ! defined_args( $sql->{name},
                            $sql->{level},
                            $sql->{password} ) ) {
            $kernel->call('console', 'put_output', "Mandatory arguments are missing.");
            return 1;
        }

        $kernel->post('client', 'get', {
            type => "core",
            data => {
              "register_client" => $sql
            },
        }, sub {
            my ($s, $k, $h, $json) = @_;

            my $result = $json->{result} // [];

            # TODO post process result with client aware components

            $kernel->call('console', 'put_output', Dumper($result));
        });

        return 1;
    }

    return 0;
}

sub update_client {
    my ($kernel, $heap, $data) = @_[KERNEL, HEAP, ARG0];

    if( $data =~ /^update\sclient\s?(.*)/) {
        my $sql = {};

        my @search_args = split(/[ ]/, $1);

        foreach my $k ( @search_args ) {
            given( $k ) {
                when(/^--id=([^ ]*)/) {
                    $sql->{id} = $1;
                }
                when(/^--name=([^ ]*)/) {
                    $sql->{name} = $1;
                }
                when(/^--acl=([^ ]*)/) {
                    $sql->{level} = $1;
                }
                when(/^--password=([^ ]*)/) {
                    $sql->{password} = sha256_hex($1);
                }
                when(/^--description=([^ ]*)/) {
                    $sql->{description} = $1;
                }
                default {
                    $kernel->call('console', 'put_output', 'Unsupported parameter: ' . $k);
                    return 1;
                }
            }
        }

        if( ! defined_args( $sql->{id} )  ){
            $kernel->call('console', 'put_output', "Mandatory arguments are missing.");
            return 1;
        }

        $kernel->post('client', 'get', {
            type => "core",
            data => {
              "update_client" => $sql
            },
        }, sub {
            my ($s, $k, $h, $json) = @_;

            my $result = $json->{result} // [];

            # TODO post process result with client aware components

            $kernel->call('console', 'put_output', Dumper($result));
        });

        return 1;
    }

    return 0;
}

sub unregister_client {
    my ($kernel, $heap, $data) = @_[KERNEL, HEAP, ARG0];

    if( $data =~ /^unregister\sclient\s?(.*)/) {
        my $sql = {};

        my @search_args = split(/[ ]/, $1);

        foreach my $k ( @search_args ) {
            given( $k ) {
                when(/^--id=([^ ]*)/) {
                    $sql->{id} = $1;
                }
                default {
                    $kernel->call('console', 'put_output', 'Unsupported parameter: ' . $k);
                    return 1;
                }
            }
        }

        $kernel->post('client', 'get', {
            type => "core",
            data => {
              "unregister_client" => $sql
            },
        }, sub {
            my ($s, $k, $h, $json) = @_;

            my $result = $json->{result} // [];

            # TODO post process result with client aware components

            $kernel->call('console', 'put_output', Dumper($result));
        });

        return 1;
    }

    return 0;
}

sub register_node {
    my ($kernel, $heap, $data) = @_[KERNEL, HEAP, ARG0];

    if( $data =~ /^register\snode\s?(.*)/) {
        my $sql = {};

        my @search_args = split(/[ ]/, $1);

        foreach my $k ( @search_args ) {
            given( $k ) {
                when(/^--name=([^ ]*)/) {
                    $sql->{name} = $1;
                }
                when(/^--agent=([^ ]*)/) {
                    $sql->{agent_id} = $1;
                }
                when(/^--password=([^ ]*)/) {
                    $sql->{password} = sha256_hex($1);
                }
                when(/^--description=([^ ]*)/) {
                    $sql->{description} = $1;
                }
                default {
                    $kernel->call('console', 'put_output', 'Unsupported parameter: ' . $k);
                    return 1;
                }
            }
        }

        if( ! defined_args( $sql->{name},
                            $sql->{agent_id},
                            $sql->{password} ) ) {
            $kernel->call('console', 'put_output', "Mandatory arguments are missing.");
            return 1;
        }

        $kernel->post('client', 'get', {
            type => "core",
            data => {
              "register_node" => $sql
            },
        }, sub {
            my ($s, $k, $h, $json) = @_;

            my $result = $json->{result} // [];

            # TODO post process result with client aware components

            $kernel->call('console', 'put_output', Dumper($result));
        });

        return 1;
    }

    return 0;
}

sub update_node {
    my ($kernel, $heap, $data) = @_[KERNEL, HEAP, ARG0];

    if( $data =~ /^update\snode\s?(.*)/) {
        my $sql = {};

        my @search_args = split(/[ ]/, $1);

        foreach my $k ( @search_args ) {
            given( $k ) {
                when(/^--id=([^ ]*)/) {
                    $sql->{id} = $1;
                }
                when(/^--name=([^ ]*)/) {
                    $sql->{name} = $1;
                }
                when(/^--agent=([^ ]*)/) {
                    $sql->{agent_id} = $1;
                }
                when(/^--password=([^ ]*)/) {
                    $sql->{password} = sha256_hex($1);
                }
                when(/^--description=([^ ]*)/) {
                    $sql->{description} = $1;
                }
                default {
                    $kernel->call('console', 'put_output', 'Unsupported parameter: ' . $k);
                    return 1;
                }
            }
        }

        if( ! defined_args( $sql->{id} )  ){
            $kernel->call('console', 'put_output', "Mandatory arguments are missing.");
            return 1;
        }

        $kernel->post('client', 'get', {
            type => "core",
            data => {
              "update_node" => $sql
            },
        }, sub {
            my ($s, $k, $h, $json) = @_;

            my $result = $json->{result} // [];

            # TODO post process result with client aware components

            $kernel->call('console', 'put_output', Dumper($result));
        });

        return 1;
    }

    return 0;
}

sub unregister_node {
    my ($kernel, $heap, $data) = @_[KERNEL, HEAP, ARG0];

    if( $data =~ /^unregister\snode\s?(.*)/) {
        my $sql = {};

        my @search_args = split(/[ ]/, $1);

        foreach my $k ( @search_args ) {
            given( $k ) {
                when(/^--id=([^ ]*)/) {
                    $sql->{id} = $1;
                }
                default {
                    $kernel->call('console', 'put_output', 'Unsupported parameter: ' . $k);
                    return 1;
                }
            }
        }

        $kernel->post('client', 'get', {
            type => "core",
            data => {
              "unregister_node" => $sql
            },
        }, sub {
            my ($s, $k, $h, $json) = @_;

            my $result = $json->{result} // [];

            # TODO post process result with client aware components

            $kernel->call('console', 'put_output', Dumper($result));
        });

        return 1;
    }

    return 0;
}

sub subscribe_node {
    my ($kernel, $heap, $data) = @_[KERNEL, HEAP, ARG0];

    if( $data =~ /^subscribe\snode\s?(.*)/) {
        my $sql = {};

        my @search_args = split(/[ ]/, $1);

        foreach my $k ( @search_args ) {
            given( $k ) {
                when(/^--id=([^ ]*)/) {
                    $sql->{id} = $1;
                }
                default {
                    $kernel->call('console', 'put_output', 'Unsupported parameter: ' . $k);
                    return 1;
                }
            }
        }

        if( ! defined_args( $sql->{id} )  ){
            $kernel->call('console', 'put_output', "Mandatory arguments are missing.");
            return 1;
        }

        $kernel->post('client', 'get', {
            type => "core",
            data => {
              "subscribe_node" => $sql
            },
        }, sub {
            my ($s, $k, $h, $json) = @_;

            my $result = $json->{result} // [];

            # TODO post process result with client aware components

            $kernel->call('console', 'put_output', Dumper($result));
        });

        return 1;
    }

    return 0;
}



sub show_clients {
    my ($kernel, $heap, $data) = @_[KERNEL, HEAP, ARG0];

    if( $data =~ /^show\sclients$/) {
        $kernel->post('client', 'get', {
            type => "core",
            data => "clients_connected",
        }, sub {
            my ($s, $k, $h, $json) = @_;

            my $result = $json->{result};

            if( ref($result) eq 'HASH' ) {
                $k->call('console', 'put_output', Dumper($result));
            }
            else {
                # TODO post process result with client aware components
                $k->call('console', 'put_output', "Unknown!");
            }
        });

        return 1;
    }

    return 0;
}

sub show_nodes {
    my ($kernel, $heap, $data) = @_[KERNEL, HEAP, ARG0];

    if( $data =~ /^show\snodes$/) {
        $kernel->post('client', 'get', {
            type => "core",
            data => "nodes_connected",
        }, sub {
            my ($s, $k, $h, $json) = @_;

            my $result = $json->{result};

            if( ref($result) eq 'ARRAY' ) {

                my $total_nodes = @{ $result };
                $k->call('console', 'put_output', $total_nodes . ' node(s) ' . ( $total_nodes == 1 ? 'is' : 'are' ) . ' connected.');

                foreach my $n ( @{ $result } ) {
                    $k->call('console', 'put_output', $n->{id} . ': ' . $n->{name} . ' (' . $n->{type}. ') - ' . $n->{description});
                }
            }
            else {
                # TODO post process result with client aware components
                $k->call('console', 'put_output', "Unknown!");
            }
        });

        return 1;
    }

    return 0;
}


sub show_node_uptime {
    my ($kernel, $heap, $data) = @_[KERNEL, HEAP, ARG0];

    if( $data =~ /^node\suptime\s?(.*)$/) {

        my $id = -1;
        my @search_args = split(/[ ]/, $1);

        foreach my $k ( @search_args ) {
            given( $k ) {
                when(/^--id=([^ ]*)/) {
                    $id = $1;
                }
                default {
                    $kernel->call('console', 'put_output', 'Unsupported parameter: ' . $k);
                    return 1;
                }
            }
        }

        if ( $id <= 0 ) {
            $kernel->call('console', 'put_output', 'Invalid ID specified.');
            return 1;
        }

        $kernel->post('client', 'get', {
            type => "core",
            data => {
                node_uptime => {
                    id => $id
                }
            }
        }, sub {
            my ($s, $k, $h, $json) = @_;

            my $result = $json->{result};

            $k->call('console', 'put_output', 'Echidna Node ' . $id . ' has been up for ' . time_seconds_to_human_readable($result) . '.');
        });

        return 1;
    }

    return 0;
}

sub show_node_version {
    my ($kernel, $heap, $data) = @_[KERNEL, HEAP, ARG0];

    if( $data =~ /^node\sversion\s?(.*)$/) {
        my $id = -1;
        my @search_args = split(/[ ]/, $1);

        foreach my $k ( @search_args ) {
            given( $k ) {
                when(/^--id=([^ ]*)/) {
                    $id = $1;
                }
                default {
                    $kernel->call('console', 'put_output', 'Unsupported parameter: ' . $k);
                    return 1;
                }
            }
        }

        if ( $id <= 0 ) {
            $kernel->call('console', 'put_output', 'Invalid ID specified.');
            return 1;
        }

        $kernel->post('client', 'get', {
            type => "core",
            data => {
                node_version => {
                    id => $id
                }
            }
        }, sub {
            my ($s, $k, $h, $json) = @_;

            my $result = $json->{result};

            if( ref($result) eq 'HASH' ) {
                my $literal = 'Echidna Node ' . $id .  ' version: v' . join('.', $result->{major}, $result->{minor}, $result->{revision}) . ' (b' . $result->{build} . ')';
                $k->call('console', 'put_output', $literal);
            }
            else {
                # TODO post process result with client aware components
                $k->call('console', 'put_output', "Unknown");
            }
        });

        return 1;
    }

    return 0;
}

sub show_server_uptime {
    my ($kernel, $heap, $data) = @_[KERNEL, HEAP, ARG0];

    if( $data =~ /^server\suptime$/) {
        $kernel->post('client', 'get', {
            type => "core",
            data => "server_uptime",
        }, sub {
            my ($s, $k, $h, $json) = @_;

            my $result = $json->{result};

            $k->call('console', 'put_output', 'Echidna Server has been up for ' . time_seconds_to_human_readable($result) . '.');
        });

        return 1;
    }

    return 0;
}

sub show_server_version {
    my ($kernel, $heap, $data) = @_[KERNEL, HEAP, ARG0];

    if( $data =~ /^server\sversion$/) {
        $kernel->post('client', 'get', {
            type => "core",
            data => "server_version",
        }, sub {
            my ($s, $k, $h, $json) = @_;

            my $result = $json->{result};

            if( ref($result) eq 'HASH' ) {
                my $literal = 'Echidna Server version: v' . join('.', $result->{major}, $result->{minor}, $result->{revision}) . ' (b' . $result->{build} . ')';
                $k->call('console', 'put_output', $literal);
            }
            else {
                # TODO post process result with client aware components
                $k->call('console', 'put_output', "Unknown");
            }
        });

        return 1;
    }

    return 0;
}

# Splits a string of values into an array of hashes to be used in a sql OR
sub split2aoh {
    my ($field,$value) = @_;
    my @values = split(/,/, $value);
    my $aoh = [];
    foreach my $key (@values) {
        push @$aoh, { "$field" => $key };
    }
    return $aoh;
}


sub search_session {
    my ($kernel, $heap, $data) = @_[KERNEL, HEAP, ARG0];

    if( $data =~ /^search\ssession\s?(.*)/) {
        my $sql = {};

        my @search_args = split(/[ ]/, $1);

        foreach my $k ( @search_args ) {
            given( $k ) {
                when(/^--timestamp=([^ ]*)/) {
                    $sql->{timestamp} = $1;
                }
                when(/^--time-start=([^ ]*)/) {
                    $sql->{time_start} = $1;
                }
                when(/^--time-end=([^ ]*)/) {
                    $sql->{time_end} = $1;
                }
                when(/^--time-duration=([^ ]*)/) {
                    my $value = $1;
                    if ($value =~ /(\d+)-(\d+)/) {
                        $sql->{"\$and"} = [
                          { time_duration => { "\$gte" => $1 } },
                          { time_duration => { "\$lte" => $2 } },
                        ];
                    } elsif ($value =~ /(\d+)(,\d+)+/) {
                        $sql->{"\$or"} = split2aoh('time_duration',$value);
                    } else {
                        $sql->{time_duration} = $value;
                    }
                }
                when(/^--agent-id=([^ ]*)/) {
                    $sql->{agent_id} = $1;
                }
                when(/^--node-id=([^ ]*)/) {
                    $sql->{node_id} = $1;
                }
                when(/^--src-ip=([^ ]*)/) {
                    my $value = $1;
                    if ($value =~ /(\d+)-(\d+)/) {
                        $sql->{"\$and"} = [
                          { net_src_ip => { "\$gte" => $1 } },
                          { net_src_ip => { "\$lte" => $2 } },
                        ];
                    } elsif ($value =~ /(\d+)(,\d+)+/) {
                       $sql->{"\$or"} = split2aoh('net_src_ip',$value);
                    } else {
                        $sql->{net_src_ip} = $1;
                    }
                }
                when(/^--src-port=([^ ]*)/) {
                    my $value = $1;
                    if ($value =~ /(\d+)-(\d+)/) {
                        $sql->{"\$and"} = [
                          { net_src_port => { "\$gte" => $1 } },
                          { net_src_port => { "\$lte" => $2 } },
                        ];
                    } elsif ($value =~ /(\d+)(,\d+)+/) {
                       $sql->{"\$or"} = split2aoh('net_src_port',$value);
                    } else {
                        $sql->{net_src_port} = $1;
                    }
                }
                when(/^--src-total-bytes=([^ ]*)/) {
                    my $value = $1;
                    if ($value =~ /(\d+)-(\d+)/) {
                        $sql->{"\$and"} = [
                          { net_src_total_bytes => { "\$gte" => $1 } },
                          { net_src_total_bytes => { "\$lte" => $2 } },
                        ];
                    } elsif ($value =~ /(\d+)(,\d+)+/) {
                       $sql->{"\$or"} = split2aoh('net_src_total_bytes',$value);
                    } else {
                        $sql->{net_src_total_bytes} = $1;
                    }
                }
                when(/^--src-total-packets=([^ ]*)/) {
                    my $value = $1;
                    if ($value =~ /(\d+)-(\d+)/) {
                        $sql->{"\$and"} = [
                          { net_src_total_packets => { "\$gte" => $1 } },
                          { net_src_total_packets => { "\$lte" => $2 } },
                        ];
                    } elsif ($value =~ /(\d+)(,\d+)+/) {
                       $sql->{"\$or"} = split2aoh('net_src_total_packets',$value);
                    } else {
                        $sql->{net_src_total_packets} = $1;
                    }
                }
                when(/^--src-flagss=([^ ]*)/) {
                    $sql->{net_src_flags} = $1;
                }
                when(/^--dst-ip=([^ ]*)/) {
                    my $value = $1;
                    if ($value =~ /(\d+)-(\d+)/) {
                        $sql->{"\$and"} = [
                          { net_dst_ip => { "\$gte" => $1 } },
                          { net_dst_ip => { "\$lte" => $2 } },
                        ];
                    } elsif ($value =~ /(\d+)(,\d+)+/) {
                       $sql->{"\$or"} = split2aoh('net_dst_ip',$value);
                    } else {
                        $sql->{net_dst_ip} = $1;
                    }
                }
                when(/^--dst-port=([^ ]*)/) {
                    my $value = $1;
                    if ($value =~ /(\d+)-(\d+)/) {
                        $sql->{"\$and"} = [
                          { net_dst_port => { "\$gte" => $1 } },
                          { net_dst_port => { "\$lte" => $2 } },
                        ];
                    } elsif ($value =~ /(\d+)(,\d+)+/) {
                       $sql->{"\$or"} = split2aoh('net_dst_port',$value);
                    } else {
                        $sql->{net_dst_port} = $1;
                    }
                }
                when(/^--dst-total-bytes=([^ ]*)/) {
                    my $value = $1;
                    if ($value =~ /(\d+)-(\d+)/) {
                        $sql->{"\$and"} = [
                          { net_dst_total_bytes => { "\$gte" => $1 } },
                          { net_dst_total_bytes => { "\$lte" => $2 } },
                        ];
                    } elsif ($value =~ /(\d+)(,\d+)+/) {
                       $sql->{"\$or"} = split2aoh('net_dst_total_bytes',$value);
                    } else {
                        $sql->{net_dst_total_bytes} = $1;
                    }
                }
               when(/^--dst-total-packets=([^ ]*)/) {
                    my $value = $1;
                    if ($value =~ /(\d+)-(\d+)/) {
                        $sql->{"\$and"} = [
                          { net_dst_total_packets => { "\$gte" => $1 } },
                          { net_dst_total_packets => { "\$lte" => $2 } },
                        ];
                    } elsif ($value =~ /(\d+)(,\d+)+/) {
                       $sql->{"\$or"} = split2aoh('net_dst_total_packets',$value);
                    } else {
                        $sql->{net_dst_total_packets} = $1;
                    }
                }
                when(/^--dst-flagss=([^ ]*)/) {
                    $sql->{net_dst_flags} = $1;
                }
                when(/^--ip=([^ ]*)/) {
                    $sql->{"\$or"} = [
                      { net_src_ip => $1 },
                      { net_dst_ip => $1 }
                    ];
                }
                when(/^--port=([^ ]*)/) {
                    $sql->{"\$or"} = [
                      { net_src_port => $1 },
                      { net_dst_port => $1 }
                    ];
                }
                when(/^--protocol=([^ ]*)/) {
                    my $value = $1;
                    if ($value =~ /(\d+)-(\d+)/) {
                        $sql->{"\$and"} = [
                          { net_protocol => { "\$gte" => $1 } },
                          { net_protocol => { "\$lte" => $2 } },
                        ];
                    } elsif ($value =~ /(\d+)(,\d+)+/) {
                       $sql->{"\$or"} = split2aoh('net_protocol',$value);
                    } else {
                        $sql->{net_protocol} = $1;
                    }
                }
                when(/^--version=([^ ]*)/) {
                    $sql->{net_version} = $1;
                }
                default {
                    $kernel->call('console', 'put_output', 'Unsupported parameter: ' . $k);
                    return 1;
                }
            }
        }

        $kernel->post('client', 'get', {
            type => "core",
            data => {
              "search_session" => $sql
            },
        }, sub {
            my ($s, $k, $h, $json) = @_;

            my $result = $json->{result} // [];

            # TODO post process result with client aware components

            $k->call('console', 'put_output',  "Total records: " . @{ $result });
        });

        return 1;
    }

    return 0;
}



sub search_event {
    my ($kernel, $heap, $data) = @_[KERNEL, HEAP, ARG0];

    if( $data =~ /^search\sevent\s?(.*)/) {
        my $sql = {};

        my @search_args = split(/[ ]/, $1);

        foreach my $k ( @search_args ) {
            given( $k ) {
                when(/^--timestamp=([^ ]*)/) {
                    $sql->{timestamp} = $1;
                }
                when(/^--classification=([^ ]*)/) {
                    $sql->{timestamp} = $1;
                }
                when(/^--node-id=([^ ]*)/) {
                    $sql->{node_id} = $1;
                }
                when(/^--src-ip=([^ ]*)/) {
                    $sql->{net_src_ip} = $1;
                }
                when(/^--src-port=([^ ]*)/) {
                    $sql->{net_src_port} = $1;
                }
                when(/^--dst-ip=([^ ]*)/) {
                    $sql->{net_dst_ip} = $1;
                }
                when(/^--dst-port=([^ ]* )/) {
                    $sql->{net_dst_port} = $1;
                }
                when(/^--protocol=([^ ]*)/) {
                    $sql->{net_protocol} = $1;
                }
                when(/^--version=([^ ]*)/) {
                    $sql->{net_version} = $1;
                }
                when(/^--ip=([^ ]*)/) {
                    $sql->{"\$or"} = [
                      { net_src_ip => $1 },
                      { net_dst_ip => $1 }
                    ];
                }
                when(/^--port=([^ ]*)/) {
                    $sql->{"\$or"} = [
                      { net_src_port => $1 },
                      { net_dst_port => $1 }
                    ];
                }
                when(/^--sig-id=([^ ]*)/) {
                    $sql->{sig_id} = $1;
                }
                when(/^--sig-revision=([^ ]*)/) {
                    $sql->{sig_revision} = $1;
                }
                when(/^--sig-priority=([^ ]*)/) {
                    $sql->{sig_priority} = $1;
                }
                when(/^--sig-message=([^ ]*)/) {
                    $sql->{sig_message} = $1;
                }
                when(/^--sig-category=([^ ]*)/) {
                    $sql->{sig_category} = $1;
                }
                default {
                    $kernel->call('console', 'put_output', 'Unsupported parameter: ' . $k);
                    return 1;
                }
            }
        }

        $kernel->post('client', 'get', {
            type => "core",
            data => {
              "search_event" => $sql
            },
        }, sub {
            my ($s, $k, $h, $json) = @_;

            my $result = $json->{result} // [];

            # TODO post process result with client aware components

            $k->call('console', 'put_output',  "Total records: " . @{ $result });
        });

        return 1;
    }

    return 0;
}


